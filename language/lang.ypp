%{
#include <string>
#include <memory>
#include <utility>
#include <map>
#include <syntax.hpp>
#include <utils/reader.hpp>
#include <utils/control.hpp>
#include <boost/algorithm/string.hpp>

#define YYDEBUG 1
#define YYERROR_VERBOSE 1

jawe::Command* program;
void *err_block;

void yyerror(const std::string&);
extern int yylex();
%}

%union {
	jawe::CommandBlock* block;
	jawe::Command* command;
	jawe::Expr* expr;
	double number;
	std::string* string;
	std::vector<jawe::Expr*>* expr_vec;
	std::vector<jawe::Command*> *comm_vec;
	std::vector<std::string> *string_vec;
	std::map<std::string, jawe::Expr*> *key_vals;
	std::pair<std::string, jawe::Expr*> *key_val;
}

%token delim_token

%token<string> id_token

%token undefined_token
%token null_token
%token nan_token
%token true_token
%token false_token
%token<number> num_token
%token<string> string_token

%token return_token
%token break_token
%token cont_token

%token if_token
%token else_token
%token switch_token
%token case_token
%token while_token
%token for_token
%token do_token
%token default_token

%token assign_token ass_plus_token ass_minus_token ass_pow_token ass_mult_token ass_div_token ass_mod_token ass_sh_l_token ass_sh_r_token ass_sh_u_token ass_con_b_token ass_xor_b_token ass_dis_b_token
%token log_or_token
%token log_and_token
%token bit_or_token
%token bit_xor_token
%token bit_and_token
%token eq_token not_eq_token t_eq_token t_not_eq_token
%token less_token less_eq_token great_token great_eq_token in_token instanceof_token
%token bit_shift_l_token bit_shift_r_token bit_shift_u_token
%token plus_token minus_token
%token times_token divide_token mod_token
%token power_token
%token inc_token dec_token log_not_token bit_not_token delete_token void_token typeof_token
%token new_token
%token function_token
%token const_token let_token var_token
%token bracket_token bracket_closed dot_access_token

%nonassoc '{' '}'
%nonassoc no_else_token
%nonassoc phony_lval
%nonassoc else_token
%left comma_token
%right assign_token ass_plus_token ass_minus_token ass_pow_token ass_mult_token ass_div_token ass_mod_token ass_sh_l_token ass_sh_r_token ass_sh_u_token ass_con_b_token ass_xor_b_token ass_dis_b_token
%right '?' ':'
%left log_or_token
%left log_and_token
%left bit_or_token
%left bit_xor_token
%left bit_and_token
%left eq_token not_eq_token t_eq_token t_not_eq_token
%left less_token less_eq_token great_token great_eq_token in_token instanceof_token
%left bit_shift_l_token bit_shift_r_token bit_shift_u_token
%left plus_token minus_token
%left times_token divide_token mod_token
%right power_token
%right inc_token dec_token log_not_token bit_not_token uplus_token uminus_token delete_token void_token typeof_token
%nonassoc post_inc post_dec
%left '(' fn_call_token
%nonassoc new_token
%left bracket_token dot_access_token
%left prec_parens_token

%type<command> Command Undelimited Delimited 
%type<block> CodeBlock LambdaBody
%type<command> Cond While For DoWhile SwitchCase Case Default
%type<command> NamedFun Declaration
%type<expr> Expr Assign LValue Literal Primitive IndexedObj ArrLiteral ObjLiteral Lambda
%type<string> Key
%type<expr_vec> LiteralList ArgList ArgListNone ArgListFull
%type<key_vals> KVLiterals
%type<key_val> KVLiteral
%type<comm_vec> Cases
%type<string_vec> IDList IDListFull IDListEmpty
%%

/****************************************************** Command Structure ******************************************************/
Program		: CodeBlock									{ program = $1;															}
		 	;
CodeBlock	: CodeBlock Command 						{ $$ = $1; $$->insert($2); $2->set_parent($1);							}
		 	| Command									{ $$ = new jawe::CommandBlock($1); $1->set_parent($$);					}
			;
Command		: Delimited delim_token						{ $$ = $1;																}
		 	| Undelimited								{ $$ = $1; 																}
			;
Undelimited	: Cond										{ $$ = $1; 																}
			| While										{ $$ = $1; 																}
			| For										{ $$ = $1; 																}
			| SwitchCase								{ $$ = $1; 																}
			| NamedFun									{ $$ = $1; 																}
			| '{' CodeBlock '}'							{ $$ = $2; 																}
			;
Delimited	: Expr										{ $$ = $1; 																}
		 	| Declaration								{ $$ = $1; 																}
			| DoWhile									{ $$ = $1; 																}
			| return_token Expr							{ $$ = new jawe::Return($2); 											}
			| cont_token								{ $$ = new jawe::Continue(); 											}
			| break_token								{ $$ = new jawe::Break();												}
			|											{ $$ = new jawe::Empty();												}
			;
NamedFun	: function_token id_token '(' IDList ')'
		 		'{' CodeBlock '}'						{ $$ = new jawe::FunctionDeclaration(*$2, new jawe::Function(*$4, $7)); delete $2; delete $4; $7->set_parent($$); }
			;
Declaration	: const_token id_token						{ $$ = new jawe::ConstDeclaration(new jawe::Variable(*$2)); delete $2;	}
			| const_token Assign						{ $$ = new jawe::ConstDeclaration($2);									}
			| var_token id_token						{ $$ = new jawe::VarDeclaration(new jawe::Variable(*$2)); delete $2;	}
			| var_token Assign							{ $$ = new jawe::VarDeclaration($2);									}
			| let_token id_token						{ $$ = new jawe::LetDeclaration(new jawe::Variable(*$2)); delete $2;	}
			| let_token Assign 							{ $$ = new jawe::LetDeclaration($2); err_block = &@2;					}
			;
Cond		: if_token '(' Expr ')' Command
	  			%prec no_else_token						{ $$ = new jawe::IfElse($3, $5); $5->set_parent($$);					}
	  		| if_token '(' Expr ')' Command
				else_token Command						{ $$ = new jawe::IfElse($3, $5, $7); $5->set_parent($$); $7->set_parent($$); }
			;
While		: while_token '(' Expr ')' Command			{ $$ = new jawe::While($3, $5); $5->set_parent($$);						}
	   		;
For			: for_token '('
	          Delimited delim_token
			  Expr delim_token
			  Delimited ')'
			  Command									{ $$ = new jawe::For($3, $5, $7, $9);
			  												$3->set_parent($$);
			  												$7->set_parent($$);
			  												$9->set_parent($$);
			  											}
	  		;
DoWhile		: do_token Command while_token '(' Expr ')'	{ $$ = new jawe::DoWhile($2, $5); $2->set_parent($$);					}
		 	;
SwitchCase	: switch_token '(' Expr ')' '{' Cases '}'	{ $$ = new jawe::Switch($3, *$6); delete $6; 							}
		   	;
Cases		: Cases Case								{ $$ = $1; $$->push_back($2); 											}
			| Cases Default								{ $$ = $1; $$->push_back($2); 											}
			| Case 										{ $$ = new std::vector<jawe::Command*>{$1}; 							}
			| Default									{ $$ = new std::vector<jawe::Command*>{$1}; 							}
			;
Case		: case_token Primitive ':' Command 			{ $$ = new jawe::Case(static_cast<jawe::Primitive*>($2), $4); $4->set_parent($$); }
	  		;
Default		: default_token ':' Command					{ $$ = new jawe::Default($3); $3->set_parent($$);						}
		 	;
/*******************************************************************************************************************************/





/********************************************************* Expressions *********************************************************/
Expr		: Expr plus_token Expr						{ $$ = new jawe::Plus($1, $3);											}
	 		| Expr minus_token Expr						{ $$ = new jawe::Minus($1, $3);											}
	 		| Expr times_token Expr						{ $$ = new jawe::Times($1, $3);											}
	 		| Expr divide_token Expr					{ $$ = new jawe::Divide($1, $3);										}
	 		| Expr mod_token Expr						{ $$ = new jawe::Mod($1, $3);											}
			| Expr power_token Expr						{ $$ = new jawe::Mod($1, $3);											}
			| plus_token Expr %prec uplus_token			{ $$ = new jawe::UPlus($2);												}
			| minus_token Expr %prec uminus_token		{ $$ = new jawe::UMinus($2);											}

			| inc_token Expr							{ $$ = new jawe::Increment($2);											}
			| dec_token Expr							{ $$ = new jawe::Decrement($2);											}
			| Expr inc_token %prec post_inc				{ $$ = new jawe::PostIncrement($1);										}
			| Expr dec_token %prec post_dec				{ $$ = new jawe::PostDecrement($1);										}
			| delete_token Expr							{ $$ = new jawe::Delete($2); 											}
			| typeof_token Expr							{ $$ = new jawe::TypeOf($2);											}
			| void_token Expr							{ $$ = new jawe::Void($2);												}
			
			| Expr eq_token Expr						{ $$ = new jawe::Equals($1, $3);										}
			| Expr not_eq_token Expr					{ $$ = new jawe::NotEquals($1, $3);										}
			| Expr t_eq_token Expr						{ $$ = new jawe::TypedEquals($1, $3);									}
			| Expr t_not_eq_token Expr					{ $$ = new jawe::TypedNotEquals($1, $3);								}
			| Expr less_token Expr						{ $$ = new jawe::LessThen($1, $3);										}
			| Expr less_eq_token Expr					{ $$ = new jawe::LessOrEquals($1, $3);									}
			| Expr great_token Expr						{ $$ = new jawe::GreaterThen($1, $3);									}
			| Expr great_eq_token Expr					{ $$ = new jawe::GreaterOrEquals($1, $3);								}
			| Expr in_token Expr						{ $$ = new jawe::In($1, $3);											}
			| Expr instanceof_token Expr				{ $$ = new jawe::InstanceOf($1, $3);									}

			| log_not_token Expr						{ $$ = new jawe::LogicNot($2);											}
			| Expr log_and_token Expr					{ $$ = new jawe::LogicAnd($1, $3);										}
			| Expr log_or_token Expr					{ $$ = new jawe::LogicOr($1, $3);										}

			| bit_not_token Expr						{ $$ = new jawe::BitNot($2);											}
			| Expr bit_and_token Expr					{ $$ = new jawe::BitAnd($1, $3);										}
			| Expr bit_or_token Expr					{ $$ = new jawe::BitOr($1, $3);											}
			| Expr bit_xor_token Expr					{ $$ = new jawe::BitXor($1, $3);										}
			| Expr bit_shift_l_token Expr				{ $$ = new jawe::BitShiftLeft($1, $3);									}
			| Expr bit_shift_r_token Expr				{ $$ = new jawe::BitShiftRight($1, $3);									}
			| Expr bit_shift_u_token Expr				{ $$ = new jawe::BitShiftUnsigned($1, $3);								}

			| Expr '?' Expr ':' Expr					{ $$ = new jawe::TernaryConditional($1, $3, $5);						}

   			| '(' Expr ')' %prec prec_parens_token		{ $$ = $2;																}
			
			| new_token Expr							{ $$ = new jawe::New($2);												}

			| Expr '(' ArgList ')' %prec fn_call_token	{ $$ = new jawe::FunctionCall($1, *$3);	delete $3;						}
			| LValue %prec phony_lval					{ $$ = $1;																}
  			| Literal									{ $$ = $1; 																}

			| Assign									{ $$ = $1;																}
  			;
LValue		: Expr bracket_token Expr bracket_closed	{ $$ = new jawe::ArrayAccess($1, $3);									}
			| Expr dot_access_token Expr				{ $$ = new jawe::DotAccess($1, $3);										}
			| id_token									{ $$ = new jawe::Variable(*$1); delete $1;								}
			;
ArgList		: ArgListNone								{ $$ = $1;																}
		 	| ArgListFull								{ $$ = $1;																}
			;
ArgListFull	: ArgListFull comma_token Expr				{ $$ = $1; $$->push_back($3);											}
		 	| Expr										{ $$ = new std::vector<jawe::Expr*>{$1};								}
			;
ArgListNone	: 											{ $$ = new std::vector<jawe::Expr*>;									}
			;
Assign		: LValue assign_token Expr					{ $$ = new jawe::Assign($1, $3);										}
			| LValue ass_plus_token Expr				{ $$ = new jawe::AssignPlus($1, $3);									}
			| LValue ass_minus_token Expr				{ $$ = new jawe::AssignMinus($1, $3);			 						} 
			| LValue ass_pow_token Expr					{ $$ = new jawe::AssignPow($1, $3);				 						}
			| LValue ass_mult_token Expr				{ $$ = new jawe::AssignMul($1, $3);				 						}
			| LValue ass_div_token Expr					{ $$ = new jawe::AssignDiv($1, $3);				 						}
			| LValue ass_mod_token Expr					{ $$ = new jawe::AssignMod($1, $3);				 						}
			| LValue ass_sh_l_token Expr				{ $$ = new jawe::AssignShiftL($1, $3);			 						}
			| LValue ass_sh_r_token Expr				{ $$ = new jawe::AssignShiftR($1, $3);			 						}
			| LValue ass_sh_u_token Expr				{ $$ = new jawe::AssignShiftU($1, $3);			 						}
			| LValue ass_con_b_token Expr				{ $$ = new jawe::AssignBitCon($1, $3);			 						}
			| LValue ass_xor_b_token Expr				{ $$ = new jawe::AssignBitXor($1, $3);			 						}
			| LValue ass_dis_b_token Expr				{ $$ = new jawe::AssignBitDis($1, $3);			 						}
			;
/*******************************************************************************************************************************/





/********************************************************* Literals ************************************************************/
Literal		: Primitive									{ $$ = $1; 																}
			| IndexedObj								{ $$ = $1; 																}
			| Lambda									{ $$ = $1;																}
			;
Primitive	: undefined_token							{ $$ = new jawe::Undefined();											}
		 	| null_token								{ $$ = new jawe::Null();												}
			| nan_token									{ $$ = new jawe::Nan();													}
			| true_token								{ $$ = new jawe::True();												}
			| false_token								{ $$ = new jawe::False();												}
			| num_token									{ $$ = new jawe::Numeric($1);											}
			| string_token								{ $$ = new jawe::String(*$1); delete $1;								}
			;
IndexedObj	: ArrLiteral								{ $$ = $1; 																}
			| ObjLiteral								{ $$ = $1; 																}
			;
ArrLiteral	: bracket_token LiteralList bracket_closed	{ $$ = new jawe::Array(*$2); delete $2;									}
		  	;
LiteralList	: LiteralList comma_token Expr				{ $$ = $1; $$->push_back($3);											}
		 	| Expr										{ $$ = new std::vector<jawe::Expr*>{$1};								}
			|											{ $$ = new std::vector<jawe::Expr*>();									}
			;
ObjLiteral	: '{' KVLiterals '}'						{ $$ = new jawe::Object(*$2); delete $2;								}
		  	;
KVLiterals	: KVLiterals comma_token KVLiteral			{ $$ = $1; (*$$)[$3->first] = $3->second; delete $3;					}
		   	| KVLiteral									{ $$ = new std::map<std::string, jawe::Expr*>; (*$$)[$1->first] = $1->second; delete $1; }
			|											{ $$ = new std::map<std::string, jawe::Expr*>;							}
			;
KVLiteral	: Key ':' Expr								{ $$ = new std::pair<std::string, jawe::Expr*>(*$1, $3); delete $1;		}
		  	;
Key			: string_token								{ $$ = $1; 																}
	  		| id_token									{ $$ = $1; 																}
			;
Lambda		: function_token '(' IDList ')'
				'{' LambdaBody '}'						{ $$ = new jawe::Function(*$3, $6); delete $3;							}
LambdaBody	: CodeBlock									{ $$ = $1;																}
		   	|											{ $$ = new jawe::CommandBlock();										}
			;
IDList		: IDListFull								{ $$ = $1; 																}
			| IDListEmpty								{ $$ = $1; 																}
			;
IDListFull	: IDListFull comma_token id_token			{ $$ = $1; $$->push_back(*$3); delete $3;								}
			| id_token									{ $$ = new std::vector<std::string>{*$1}; delete $1;					}
			;
IDListEmpty	:											{ $$ = new std::vector<std::string>;									}
			;
/*******************************************************************************************************************************/

%%

void yyerror(const std::string& msg) {
	std::string filename = jawe::Control::get().input_filename();
	int line = jawe::Reader::get_reader().get_line();
	int position = jawe::Reader::get_reader().get_position();
	std::string buff = jawe::Reader::get_reader().get_buffer();
	YYLTYPE* block = (YYLTYPE*)err_block;
	
	if( block ) {
		line = block->first_line + 1;
		position = block->first_column;
	}

	std::cerr	<< "[ERROR] "
				<< filename
				<< ":" << (line)
				<< ":" << (position) 
				<< ": " << msg
				<< std::endl;

	buff = jawe::Reader::get_reader().get_line(line-1);
	int old_len = buff.size();
	boost::trim(buff);
	int new_len = buff.size();
	std::cerr	<< std::string(4, ' ');
	std::cerr	<< buff << std::endl
				<< std::string(4 + position-3 - (old_len - new_len), ' ')
				<< "--^--" << std::endl;

	std::exit(EXIT_FAILURE);
}

